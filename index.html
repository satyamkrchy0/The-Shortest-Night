<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Shortest Night</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Lora:ital@0;1&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
        }
        body {
            font-family: 'Lora', serif;
            overflow: hidden;
            cursor: none;
            background-color: #010108;

            /* Make text rendering crisper */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }
        .font-playfair { font-family: 'Playfair Display', serif; }
        #scene-container {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }
        .content-overlay {
            position: relative;
            z-index: 999;

            /* Promote to its own layer to keep subpixel AA */
            transform: translateZ(0);
            backface-visibility: hidden;
        }
        .animated-gradient-text {
            background: linear-gradient(90deg, #f0c3b2, #e79ac0, #b0cfff, #b2ffd4);
            background-size: 400% 100%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient-shift 15s ease infinite;
            text-shadow: 0 0 10px rgba(255, 199, 179, 0.4);
            transition: text-shadow 0.4s ease;
        }
        /* Only keep gradient for the title; make poem text solid and crisp */
        .poem-text {
            color: rgba(255,255,255,0.95);
            background: none !important;
            -webkit-text-fill-color: initial;
            text-shadow: none;
        }
        .poem-line-active {
            /* Softer hover glow to avoid blur */
            text-shadow: 0 0 12px rgba(255, 220, 200, 0.5), 0 0 20px rgba(231, 154, 192, 0.3);
        }
        @keyframes gradient-shift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .content-wrapper {
            animation: fadeIn 3s ease-out forwards;
        }
        .poem-line {
            opacity: 0;
            transform: translateY(15px);
            transition: opacity 0.8s ease-out, transform 0.8s ease-out, text-shadow 0.4s ease-in-out;
            will-change: opacity, transform;
            position: relative;
        }
        .poem-line.visible {
            opacity: 1;
            transform: translateY(0);
        }
        @keyframes pulseGlow {
            0%, 100% { filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.4)); }
            50% { filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.8)); }
        }
        .divider-svg { animation: pulseGlow 4s ease-in-out infinite; }
        .cursor-light {
            position: fixed;
            z-index: 1000;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(200, 225, 255, 0.5) 0%, rgba(200, 225, 255, 0) 60%);
            pointer-events: none;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease-out;
        }
        #audio-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1001;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            width: 44px; height: 44px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: background-color 0.3s;
        }
        #audio-toggle:hover { background: rgba(255,255,255,0.2); }
        /* Show 'sound on' by default */
        #sound-off-icon { display: none; }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen">
    <div id="scene-container"></div>
    <div class="cursor-light"></div>
    <div id="audio-toggle" title="Toggle sound">
        <!-- Sound ON icon -->
        <svg id="sound-on-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M11 5L6 9H3v6h3l5 4V5z"></path>
            <path d="M15.54 8.46a5 5 0 010 7.07M17.94 6.06a8 8 0 010 11.31"></path>
        </svg>
        <!-- Sound OFF icon -->
        <svg id="sound-off-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M9 9L5 9H3v6h3l5 4V13"></path>
            <path d="M19 5L5 19"></path>
        </svg>
    </div>

    <div class="content-overlay w-full max-w-lg lg:max-w-xl shadow-2xl rounded-lg aspect-[9/16] sm:aspect-[4/5] md:aspect-auto md:min-h-[80vh] flex items-center justify-center p-8 sm:p-12">
        <div class="text-center text-white/95 content-wrapper">
            <h1 class="font-playfair text-4xl sm:text-5xl md:text-6xl font-bold mb-6 tracking-wide animated-gradient-text">The Shortest Night</h1>
            <div class="w-24 mx-auto my-8">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 20" class="text-white/70 divider-svg" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round">
                    <path d="M10 10 H80 M120 10 H190"></path>
                    <circle cx="100" cy="10" r="3"></circle>
                </svg>
            </div>
            <!-- Remove gradient class from poem text for crispness -->
            <div class="poem-text text-base sm:text-lg md:text-xl leading-relaxed space-y-4 italic">
                <p class="poem-line" data-note="C5">The shortest night will come to stay,</p>
                <p class="poem-line" data-note="D5">With her beside me, shadows sway.</p>
                <p class="poem-line mt-4" data-note="E5">Whatever she carries, whatever she hides,</p>
                <p class="poem-line" data-note="G5">Her silence anchors the restless tides.</p>
                <p class="poem-line mt-4" data-note="A5">Each flower I name belongs to her light,</p>
                <p class="poem-line" data-note="C6">Each fragile arrow softens the night.</p>
                <p class="poem-line mt-4" data-note="D6">Though parted by distance, by silence, by star,</p>
                <p class="poem-line" data-note="E6">Her presence still reaches—no matter how far.</p>
            </div>
        </div>
    </div>

    <script>
        // --- Enhanced Audio ---
        const reverb = new Tone.Reverb(4).toDestination();
        const feedbackDelay = new Tone.FeedbackDelay("4n", 0.6).connect(reverb);

        const melodySynth = new Tone.FMSynth({
            harmonicity: 3,
            modulationIndex: 10,
            envelope: { attack: 0.01, decay: 2, sustain: 0.1, release: 4 },
            modulation: { type: "sine" },
            modulationEnvelope: { attack: 0.5, decay: 0, sustain: 1, release: 0.5 }
        }).connect(feedbackDelay);
        melodySynth.volume.value = -5;

        const chimeSynth = new Tone.PluckSynth({
            attackNoise: 0.2, dampening: 8000, resonance: 0.9
        }).connect(feedbackDelay);
        chimeSynth.volume.value = -8;

        const melody = new Tone.Sequence((time, note) => {
            melodySynth.triggerAttackRelease(note, "1n", time);
        }, ['A3', null, 'G3', ['E3', 'D3'], 'F3', null, 'E3', null], "1m").start(0);

        const audioToggle = document.getElementById('audio-toggle');
        audioToggle.addEventListener('click', () => {
            if (Tone.context.state !== 'running') Tone.start();
            if (Tone.Transport.state === 'started') {
                Tone.Transport.pause();
                document.getElementById('sound-on-icon').style.display = 'none';
                document.getElementById('sound-off-icon').style.display = 'block';
            } else {
                Tone.Transport.start();
                document.getElementById('sound-on-icon').style.display = 'block';
                document.getElementById('sound-off-icon').style.display = 'none';
            }
        });

        // --- Core 3D Scene ---
        const scene = new THREE.Scene();
        const container = document.getElementById('scene-container');
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        // Important: make canvas opaque to preserve crisp subpixel text AA
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: 'high-performance' });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x010108, 1); // same as body bg
        container.appendChild(renderer.domElement);

        const mouse = new THREE.Vector3(0, 0, 0.5);
        const clock = new THREE.Clock();

        // --- Aurora Borealis ---
        const auroraGeometry = new THREE.PlaneGeometry(20, 10, 200, 100);
        const auroraMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0.0 },
                uColor1: { value: new THREE.Color(0x00ffaa) },
                uColor2: { value: new THREE.Color(0xff00ff) },
            },
            vertexShader: `
                uniform float uTime;
                varying vec2 vUv;
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                float snoise(vec3 v) {
                    const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                    vec3 i = floor(v + dot(v, C.yyy));
                    vec3 x0 = v - i + dot(i, C.xxx);
                    vec3 g = step(x0.yzx, x0.xyz);
                    vec3 l = 1.0 - g;
                    vec3 i1 = min(g.xyz, l.zxy);
                    vec3 i2 = max(g.xyz, l.zxy);
                    vec3 x1 = x0 - i1 + C.xxx;
                    vec3 x2 = x0 - i2 + C.yyy;
                    vec3 x3 = x0 - D.yyy;
                    i = mod289(i);
                    vec4 p = permute(permute(permute(
                                i.z + vec4(0.0, i1.z, i2.z, 1.0))
                            + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                            + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                    float n_ = 0.142857142857;
                    vec3 ns = n_ * D.wyz - D.xzx;
                    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                    vec4 x_ = floor(j * ns.z);
                    vec4 y_ = floor(j - 7.0 * x_);
                    vec4 x = x_ * ns.x + ns.yyyy;
                    vec4 y = y_ * ns.x + ns.yyyy;
                    vec4 h = 1.0 - abs(x) - abs(y);
                    vec4 b0 = vec4(x.xy, y.xy);
                    vec4 b1 = vec4(x.zw, y.zw);
                    vec4 s0 = floor(b0) * 2.0 + 1.0;
                    vec4 s1 = floor(b1) * 2.0 + 1.0;
                    vec4 sh = -step(h, vec4(0.0));
                    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
                    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
                    vec3 p0 = vec3(a0.xy, h.x);
                    vec3 p1 = vec3(a0.zw, h.y);
                    vec3 p2 = vec3(a1.xy, h.z);
                    vec3 p3 = vec3(a1.zw, h.w);
                    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
                    p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
                    m = m * m;
                    return 42.0 * dot(m*m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
                }
                void main() {
                    vUv = uv;
                    float displacement = snoise(vec3(position.x * 2.0, position.y * 2.0, uTime * 0.3)) * 0.5;
                    vec3 newPosition = position + normal * displacement;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                }`,
            fragmentShader: `
                uniform float uTime;
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                varying vec2 vUv;
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                float snoise(vec3 v) {
                    const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                    vec3 i = floor(v + dot(v, C.yyy));
                    vec3 x0 = v - i + dot(i, C.xxx);
                    vec3 g = step(x0.yzx, x0.xyz);
                    vec3 l = 1.0 - g;
                    vec3 i1 = min(g.xyz, l.zxy);
                    vec3 i2 = max(g.xyz, l.zxy);
                    vec3 x1 = x0 - i1 + C.xxx;
                    vec3 x2 = x0 - i2 + C.yyy;
                    vec3 x3 = x0 - D.yyy;
                    i = mod289(i);
                    vec4 p = permute(permute(permute(
                                i.z + vec4(0.0, i1.z, i2.z, 1.0))
                            + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                            + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                    float n_ = 0.142857142857;
                    vec3 ns = n_ * D.wyz - D.xzx;
                    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                    vec4 x_ = floor(j * ns.z);
                    vec4 y_ = floor(j - 7.0 * x_);
                    vec4 x = x_ * ns.x + ns.yyyy;
                    vec4 y = y_ * ns.x + ns.yyyy;
                    vec4 h = 1.0 - abs(x) - abs(y);
                    vec4 b0 = vec4(x.xy, y.xy);
                    vec4 b1 = vec4(x.zw, y.zw);
                    vec4 s0 = floor(b0) * 2.0 + 1.0;
                    vec4 s1 = floor(b1) * 2.0 + 1.0;
                    vec4 sh = -step(h, vec4(0.0));
                    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
                    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
                    vec3 p0 = vec3(a0.xy, h.x);
                    vec3 p1 = vec3(a0.zw, h.y);
                    vec3 p2 = vec3(a1.xy, h.z);
                    vec3 p3 = vec3(a1.zw, h.w);
                    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
                    p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
                    m = m * m;
                    float noise = 42.0 * dot(m*m, vec4(
                        dot(vec3(a0.xy, h.x), vec3(x0.x, x0.y, x0.z)),
                        dot(vec3(a0.zw, h.y), vec3(x1.x, x1.y, x1.z)),
                        dot(vec3(a1.xy, h.z), vec3(x2.x, x2.y, x2.z)),
                        dot(vec3(a1.zw, h.w), vec3(x3.x, x3.y, x3.z))
                    ));
                    float intensity = pow(0.5 - vUv.y, 2.0);
                    vec3 color = mix(uColor1, uColor2, noise);
                    gl_FragColor = vec4(color, noise * intensity);
                }`,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
        });
        const aurora = new THREE.Mesh(auroraGeometry, auroraMaterial);
        aurora.position.z = -5;
        scene.add(aurora);

        // --- Planetary Elements ---
        // Sun
        const sunGeometry = new THREE.SphereGeometry(0.8, 32, 32);
        const sunMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0.0 },
                uColor: { value: new THREE.Color(0xffaa00) }
            },
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vPosition;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`,
            fragmentShader: `
                uniform float uTime;
                uniform vec3 uColor;
                varying vec3 vNormal;
                varying vec3 vPosition;
                void main() {
                    float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                    vec3 glow = uColor * (1.0 + intensity);
                    float flicker = 0.9 + 0.1 * sin(uTime * 3.0);
                    gl_FragColor = vec4(glow * flicker, 1.0);
                }`,
            transparent: false
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(8, 6, -8);
        scene.add(sun);

        // Moon
        const moonGeometry = new THREE.SphereGeometry(0.6, 32, 32);
        const moonMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xccccff,
            transparent: true,
            opacity: 0.9
        });
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        moon.position.set(-7, 5, -7);
        scene.add(moon);

        // Add moon craters for realism
        const craterGeometry = new THREE.SphereGeometry(0.15, 16, 16);
        const craterMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x999999,
            transparent: true,
            opacity: 0.3
        });
        for (let i = 0; i < 5; i++) {
            const crater = new THREE.Mesh(craterGeometry, craterMaterial);
            const angle = (i / 5) * Math.PI * 2;
            crater.position.set(
                moon.position.x + Math.cos(angle) * 0.3,
                moon.position.y + Math.sin(angle) * 0.3,
                moon.position.z + 0.3
            );
            scene.add(crater);
        }

        // Stars (additional fixed stars beyond particles)
        const starGeometry = new THREE.BufferGeometry();
        const starVertices = [];
        const starColors = [];
        for (let i = 0; i < 200; i++) {
            const x = (Math.random() - 0.5) * 40;
            const y = (Math.random() - 0.5) * 40;
            const z = -10 - Math.random() * 10;
            starVertices.push(x, y, z);
            
            // Vary star colors (white, blue-white, yellow-white)
            const colorChoice = Math.random();
            if (colorChoice < 0.33) {
                starColors.push(1, 1, 1); // White
            } else if (colorChoice < 0.66) {
                starColors.push(0.8, 0.9, 1); // Blue-white
            } else {
                starColors.push(1, 1, 0.8); // Yellow-white
            }
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
        const starMaterial = new THREE.PointsMaterial({
            size: 0.08,
            vertexColors: true,
            transparent: true,
            opacity: 0.9,
            sizeAttenuation: true
        });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // --- Interactive Particles ---
        const particleCount = 5000;
        const positions = new Float32Array(particleCount * 3);
        const originalPositions = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount * 3);
        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            positions[i3] = (Math.random() - 0.5) * 20;
            positions[i3 + 1] = (Math.random() - 0.5) * 20;
            positions[i3 + 2] = (Math.random() - 0.5) * 20;
            originalPositions[i3] = positions[i3];
            originalPositions[i3 + 1] = positions[i3 + 1];
            originalPositions[i3 + 2] = positions[i3 + 2];
        }
        const particleGeometry = new THREE.BufferGeometry();
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const particleMaterial = new THREE.PointsMaterial({
            color: 0xaaaaff, size: 0.02, blending: THREE.AdditiveBlending, transparent: true
        });
        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);

        // --- Stardust on Hover ---
        const stardustPool = [];
        for (let i=0; i<8; i++) {
            const stardustGeometry = new THREE.BufferGeometry();
            const stardustPositions = new Float32Array(100 * 3);
            stardustGeometry.setAttribute('position', new THREE.BufferAttribute(stardustPositions, 3));
            const stardustMaterial = new THREE.PointsMaterial({
                color: 0xffffbb, size: 0.05, transparent: true, blending: THREE.AdditiveBlending, opacity: 1, sizeAttenuation: true
            });
            const stardust = new THREE.Points(stardustGeometry, stardustMaterial);
            stardust.visible = false;
            scene.add(stardust);
            stardustPool.push({ mesh: stardust, lifetime: 0 });
        }

        function triggerStardust(lineElement) {
            const availableStardust = stardustPool.find(s => s.lifetime <= 0);
            if (!availableStardust) return;

            const rect = lineElement.getBoundingClientRect();
            const x = (rect.left + rect.width / 2) / window.innerWidth * 2 - 1;
            const y = -(rect.top + rect.height / 2) / window.innerHeight * 2 + 1;
            const vector = new THREE.Vector3(x, y, 0.5);
            vector.unproject(camera);
            availableStardust.mesh.position.copy(vector);
            availableStardust.lifetime = 1.0;
            availableStardust.mesh.visible = true;

            const positions = availableStardust.mesh.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i+=3) {
                positions[i] = (Math.random() - 0.5) * 0.1;
                positions[i+1] = (Math.random() - 0.5) * 0.1;
                positions[i+2] = (Math.random() - 0.5) * 0.1;
            }
            availableStardust.mesh.geometry.attributes.position.needsUpdate = true;
        }

        // --- Event Listeners & Animation Loop ---
        const cursorLight = document.querySelector('.cursor-light');
        const unprojectedMouse = new THREE.Vector3();

        window.addEventListener('mousemove', e => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            cursorLight.style.transform = `translate(${e.clientX}px, ${e.clientY}px)`;
        });

        document.querySelectorAll('.poem-line').forEach(line => {
            line.addEventListener('mouseenter', () => {
                line.classList.add('poem-line-active');
                chimeSynth.triggerAttackRelease(line.dataset.note, '4n');
                triggerStardust(line);
            });
            line.addEventListener('mouseleave', () => {
                line.classList.remove('poem-line-active');
            });
        });

        // --- Background Theme System ---
        let currentTheme = 0;
        const themes = [
            {
                name: 'twilight',
                auroraColor1: 0x00ffaa,
                auroraColor2: 0xff00ff,
                particleColor: 0xaaaaff,
                backgroundColor: 0x010108,
                sunVisible: true,
                moonVisible: false
            },
            {
                name: 'midnight',
                auroraColor1: 0x0066ff,
                auroraColor2: 0xff0066,
                particleColor: 0xffaaff,
                backgroundColor: 0x000005,
                sunVisible: false,
                moonVisible: true
            },
            {
                name: 'dawn',
                auroraColor1: 0xff8800,
                auroraColor2: 0xffcc00,
                particleColor: 0xffddaa,
                backgroundColor: 0x0a0510,
                sunVisible: true,
                moonVisible: true
            }
        ];

        function applyTheme(themeIndex, smooth = true) {
            const theme = themes[themeIndex % themes.length];
            
            if (smooth) {
                // Smooth color transitions
                const currentColor1 = auroraMaterial.uniforms.uColor1.value;
                const currentColor2 = auroraMaterial.uniforms.uColor2.value;
                const targetColor1 = new THREE.Color(theme.auroraColor1);
                const targetColor2 = new THREE.Color(theme.auroraColor2);
                
                let progress = 0;
                const transitionDuration = 2000; // 2 seconds
                const startTime = Date.now();
                
                function transition() {
                    const elapsed = Date.now() - startTime;
                    progress = Math.min(elapsed / transitionDuration, 1);
                    
                    auroraMaterial.uniforms.uColor1.value.lerpColors(currentColor1, targetColor1, progress);
                    auroraMaterial.uniforms.uColor2.value.lerpColors(currentColor2, targetColor2, progress);
                    particleMaterial.color.lerp(new THREE.Color(theme.particleColor), progress * 0.1);
                    
                    if (progress < 1) {
                        requestAnimationFrame(transition);
                    }
                }
                transition();
            } else {
                auroraMaterial.uniforms.uColor1.value.set(theme.auroraColor1);
                auroraMaterial.uniforms.uColor2.value.set(theme.auroraColor2);
                particleMaterial.color.set(theme.particleColor);
            }
            
            // Toggle planetary elements
            sun.visible = theme.sunVisible;
            moon.visible = theme.moonVisible;
            renderer.setClearColor(theme.backgroundColor, 1);
        }

        // Apply initial theme
        applyTheme(0, false);

        // Theme change based on scroll position or poem progression
        // For this implementation, we'll change theme based on which poem lines are visible
        let lastVisibleLineIndex = 0;
        
        function checkThemeChange() {
            const poemLines = document.querySelectorAll('.poem-line.visible');
            const visibleCount = poemLines.length;
            
            // Change theme every 10 lines (or for demo purposes, every 3 lines since we have 8)
            const newThemeIndex = Math.floor(visibleCount / 3);
            
            if (newThemeIndex !== currentTheme && newThemeIndex < themes.length) {
                currentTheme = newThemeIndex;
                applyTheme(currentTheme, true);
            }
        }

        // Check theme periodically
        setInterval(checkThemeChange, 1000);

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();

            auroraMaterial.uniforms.uTime.value = elapsedTime;
            sunMaterial.uniforms.uTime.value = elapsedTime;

            // Animate planetary elements
            sun.rotation.y += 0.001;
            moon.rotation.y += 0.002;
            
            // Twinkle stars
            const starPositions = stars.geometry.attributes.position.array;
            for (let i = 0; i < starPositions.length; i += 3) {
                const twinkle = Math.sin(elapsedTime * 2 + i) * 0.02;
                starPositions[i + 2] = -10 - (i / 3) % 10 + twinkle;
            }
            stars.geometry.attributes.position.needsUpdate = true;

            // Mouse in world-ish space at z≈5
            unprojectedMouse.set(mouse.x, mouse.y, 0.5).unproject(camera);
            const target = unprojectedMouse.clone().sub(camera.position).normalize().multiplyScalar(5);

            const particlePositions = particles.geometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const pos = new THREE.Vector3(particlePositions[i3], particlePositions[i3+1], particlePositions[i3+2]);
                const dist = pos.distanceTo(target);

                let force = new THREE.Vector3().subVectors(pos, target).normalize();
                force.multiplyScalar(0.01 / (dist * dist + 1.0));
                velocities[i3] += force.x;
                velocities[i3+1] += force.y;

                particlePositions[i3] += velocities[i3];
                particlePositions[i3+1] += velocities[i3+1];

                velocities[i3] *= 0.95;
                velocities[i3+1] *= 0.95;

                const returnForce = new THREE.Vector3(
                    originalPositions[i3] - pos.x,
                    originalPositions[i3+1] - pos.y,
                    originalPositions[i3+2] - pos.z
                ).multiplyScalar(0.001);

                particlePositions[i3] += returnForce.x;
                particlePositions[i3+1] += returnForce.y;
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // Animate stardust
            stardustPool.forEach(s => {
                if (s.lifetime > 0) {
                    s.lifetime -= delta;
                    s.mesh.material.opacity = s.lifetime;
                    const positions = s.mesh.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i+1] -= 0.001; // Gravity
                    }
                    s.mesh.geometry.attributes.position.needsUpdate = true;
                } else {
                    s.mesh.visible = false;
                }
            });

            camera.position.x += (mouse.x * 2 - camera.position.x) * 0.02;
            camera.position.y += (-mouse.y * 2 - camera.position.y) * 0.02;
            camera.lookAt(scene.position);
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.querySelectorAll('.poem-line').forEach((line, index) => {
            setTimeout(() => line.classList.add('visible'), 2000 + index * 300);
        });

        animate();
    </script>
</body>

</html>
<script>
    // --- Autoplay init (add this after your existing audio code setup) ---
    let audioInitialized = false;

    async function initAudio() {
        if (audioInitialized) return;
        audioInitialized = true;
        try {
            await Tone.start();
        } catch (e) {
            // Some browsers may still block, fallback below will handle it
            console.warn('Tone.start() was blocked or failed:', e);
        }
        // Start the transport if not already started
        if (Tone.Transport.state !== 'started') {
            // Slight scheduling offset to avoid race conditions
            Tone.Transport.start('+0.05');
        }
        // Reflect "sound on" in the UI
        const onIcon = document.getElementById('sound-on-icon');
        const offIcon = document.getElementById('sound-off-icon');
        if (onIcon && offIcon) {
            onIcon.style.display = 'block';
            offIcon.style.display = 'none';
        }
    }

    function enableAutoplayFallback() {
        // Start audio on the first meaningful user interaction
        const once = (type) => {
            const handler = () => {
                initAudio();
                cleanup();
            };
            window.addEventListener(type, handler, { once: true, passive: true });
            return () => window.removeEventListener(type, handler);
        };

        const cleanups = [
            once('pointerdown'),
            once('touchstart'),
            once('keydown'),
        ];
        function cleanup() {
            cleanups.forEach(fn => fn && fn());
        }
    }

    // Try to start immediately when the page loads
    window.addEventListener('load', async () => {
        await initAudio();
        // If context still isn't running, attach fallback listeners
        if (Tone.context.state !== 'running') {
            enableAutoplayFallback();
        }
    });

    // Also try when the tab becomes visible (covers cases where load happens in background)
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible' && Tone.context.state !== 'running') {
            initAudio();
        }
    });
</script>
